rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to check if user is a project member
    // Note: This checks the 'members' array in the project document
    function isProjectMember(projectId) {
      return isAuthenticated() && 
             request.auth.uid in get(/databases/$(database)/documents/projects/$(projectId)).data.members;
    }
    
    // Users collection
    match /users/{userId} {
      // Allow reading user profiles by authenticated users (for member search/invitations)
      allow read: if isAuthenticated();
      allow create: if isOwner(userId) && 
                      request.resource.data.keys().hasAll(['id', 'email', 'createdAt']) &&
                      request.resource.data.id == userId;
      allow update: if isOwner(userId) && 
                      request.resource.data.id == userId &&
                      request.resource.data.email == resource.data.email;
      allow delete: if isOwner(userId);
      
      // Sticky notes subcollection
      match /sticky_notes/{noteId} {
        allow read, write: if isOwner(userId);
      }

      // Notifications subcollection
      match /notifications/{notificationId} {
        // Allow user to read/update/delete their own notifications
        allow read, update, delete: if isOwner(userId);
        // Allow any authenticated user to create notifications for this user
        // (needed for invitations, task assignments, etc.)
        allow create: if isAuthenticated();
      }

      // FCM tokens subcollection
      match /fcmTokens/{token} {
        // Users can only manage their own FCM tokens
        allow read, write: if isOwner(userId);
      }

      // Settings subcollection (for Cliq notification settings, etc.)
      match /settings/{settingId} {
        allow read, write: if isOwner(userId);
      }

      // Pending Invitations subcollection
      match /pendingInvitations/{invitationId} {
        // Allow user to read/delete their own pending invitations
        allow read, delete: if isOwner(userId);
        // Allow authenticated users to create invitations for this user (sender creating invitation)
        allow create: if isAuthenticated();
        // Allow the user to update their invitations (accepting/declining)
        allow update: if isOwner(userId);
      }
    }
    
    // Projects collection
    match /projects/{projectId} {
      allow read: if isAuthenticated() && 
                    request.auth.uid in resource.data.members;
      allow create: if isAuthenticated() && 
                      request.resource.data.keys().hasAll(['name', 'members', 'createdAt']) &&
                      request.auth.uid in request.resource.data.members;
      // Allow update if user is a member, OR if user is adding themselves to members array (invitation acceptance)
      allow update: if isAuthenticated() && (
                      request.auth.uid in resource.data.members ||
                      (request.auth.uid in request.resource.data.members && 
                       !(request.auth.uid in resource.data.members))
                    );
      allow delete: if isAuthenticated() &&
                      request.auth.uid in resource.data.members;
                      
      // Members subcollection
      match /members/{memberId} {
        allow read: if isProjectMember(projectId);
        // Allow project members to write, OR allow user to add themselves (for invitation acceptance)
        allow write: if isProjectMember(projectId) || 
                       (isAuthenticated() && request.auth.uid == memberId);
      }
    }
    
    // Tasks collection
    match /tasks/{taskId} {
      // Helper to check if task is a personal task (projectId is null or doesn't exist)
      function isPersonalTask(data) {
        return !('projectId' in data) || data.projectId == null;
      }
      
      allow read: if isAuthenticated() && 
                    (isPersonalTask(resource.data)
                      ? request.auth.uid in resource.data.assignees
                      : (isProjectMember(resource.data.projectId) ||
                         request.auth.uid in resource.data.assignees));
      allow create: if isAuthenticated() && 
                      request.resource.data.keys().hasAll(['title', 'createdAt']) &&
                      (isPersonalTask(request.resource.data)
                        ? request.auth.uid in request.resource.data.assignees
                        : isProjectMember(request.resource.data.projectId));
      allow update: if isAuthenticated() && 
                      (isPersonalTask(resource.data)
                        ? request.auth.uid in resource.data.assignees
                        : isProjectMember(resource.data.projectId));
      allow delete: if isAuthenticated() && 
                      (isPersonalTask(resource.data)
                        ? request.auth.uid in resource.data.assignees
                        : isProjectMember(resource.data.projectId));
    }
    
    // Subtasks collection
    match /subtasks/{subtaskId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                      request.resource.data.keys().hasAll(['taskId', 'title']);
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    // Chat messages collection
    match /chats/{projectId}/messages/{messageId} {
      allow read: if isAuthenticated() && 
                    isProjectMember(projectId);
      allow create: if isAuthenticated() && 
                      request.resource.data.keys().hasAll(['projectId', 'senderId', 'senderName', 'text', 'createdAt']) &&
                      request.resource.data.senderId == request.auth.uid &&
                      request.resource.data.projectId == projectId &&
                      isProjectMember(projectId);
      allow update: if isAuthenticated() && 
                      resource.data.senderId == request.auth.uid &&
                      isProjectMember(projectId);
      allow delete: if isAuthenticated() && 
                      resource.data.senderId == request.auth.uid &&
                      isProjectMember(projectId);
    }
    
    // Routines collection
    match /routines/{routineId} {
      allow read: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid;
    }
    
    // Mind maps collection
    match /mindMaps/{mindMapId} {
      allow read: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid;
      
      match /nodes/{nodeId} {
        allow read: if isAuthenticated() && 
                      get(/databases/$(database)/documents/mindMaps/$(mindMapId)).data.userId == request.auth.uid;
        allow create: if isAuthenticated() && 
                        get(/databases/$(database)/documents/mindMaps/$(mindMapId)).data.userId == request.auth.uid;
        allow update: if isAuthenticated() && 
                        get(/databases/$(database)/documents/mindMaps/$(mindMapId)).data.userId == request.auth.uid;
        allow delete: if isAuthenticated() && 
                        get(/databases/$(database)/documents/mindMaps/$(mindMapId)).data.userId == request.auth.uid;
      }
    }

    // Invitations collection
    match /invitations/{invitationId} {
      allow get: if isAuthenticated() && (
        request.auth.uid == resource.data.invitedByUserId || 
        request.auth.uid == resource.data.invitedUserId ||
        request.auth.token.email == resource.data.invitedEmail
      );
      // Allow authenticated users to query invitations (for duplicate checks and listing)
      allow list: if isAuthenticated();
      // Allow any authenticated user to create invitations (additional validation in app logic)
      allow create: if isAuthenticated();
      // Allow update if user is inviter, or if user's email matches invitedEmail (for accepting/declining)
      allow update: if isAuthenticated() && (
        request.auth.uid == resource.data.invitedByUserId || 
        request.auth.uid == resource.data.invitedUserId ||
        request.auth.token.email == resource.data.invitedEmail
      );
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.invitedByUserId;
    }

    // Cliq user mappings collection (for Zoho Cliq integration)
    match /cliq_user_mappings/{mappingId} {
      // Users can read their own mappings
      allow read: if isAuthenticated() && 
                    resource.data.tasker_user_id == request.auth.uid;
      // Users can create mappings for themselves
      allow create: if isAuthenticated() && 
                      request.resource.data.tasker_user_id == request.auth.uid;
      // Users can update/delete their own mappings
      allow update, delete: if isAuthenticated() && 
                              resource.data.tasker_user_id == request.auth.uid;
    }

    // Cliq linking codes collection (temporary codes for account linking)
    match /cliq_linking_codes/{codeId} {
      // Users can read/write their own linking codes
      allow read: if isAuthenticated() && 
                    resource.data.tasker_user_id == request.auth.uid;
      allow create: if isAuthenticated() && 
                      request.resource.data.tasker_user_id == request.auth.uid;
      allow update, delete: if isAuthenticated() && 
                              resource.data.tasker_user_id == request.auth.uid;
    }
    
    // Deny all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
