# Firebase Firestore Structure Documentation

> **Purpose**: This document serves as the single source of truth for the Firestore database schema used by both the Flutter mobile app and the Node.js web backend. All field names, types, and structures must match exactly to ensure data consistency.

**Last Updated**: January 2025  
**Flutter SDK**: ^3.9.2  
**Firebase**: firebase_core ^4.2.1, cloud_firestore ^6.1.0

---

## Table of Contents

- [Overview](#overview)
- [Collections](#collections)
  - [users](#1-users-collection)
  - [projects](#2-projects-collection)
  - [tasks](#3-tasks-collection)
  - [subtasks](#4-subtasks-collection)
  - [routines](#5-routines-collection)
  - [invitations](#6-invitations-collection)
  - [mindMaps](#7-mindmaps-collection)
  - [mindMapNodes](#8-mindmapnodes-collection)
- [Subcollections](#subcollections)
  - [projects/{projectId}/members](#subcollection-projectsmembers)
  - [projects/{projectId}/messages](#subcollection-projectsmessages)
  - [users/{userId}/sticky_notes](#subcollection-userssticky_notes)
  - [users/{userId}/notifications](#subcollection-usersnotifications)
  - [users/{userId}/pendingInvitations](#subcollection-userspendinginvitations)
- [Data Type Mapping](#data-type-mapping)
- [Timestamp Handling](#timestamp-handling)
- [Enum Serialization](#enum-serialization)
- [Indexes Required](#indexes-required)
- [Security Rules Summary](#security-rules-summary)
- [Consistency Guidelines](#consistency-guidelines)

---

## Overview

### Architecture Principles

1. **Offline-First**: Flutter app uses Hive for local caching, Firestore for cloud sync
2. **Timestamp Format**: Firestore `Timestamp` type (converts to DateTime in Dart, ISO 8601 strings for web)
3. **Enum Storage**: Store enums as lowercase strings matching enum value names
4. **IDs**: Document IDs generated by Firestore (auto-ID) unless specified
5. **Soft Deletes**: Chat messages use `isDeleted` flag; other entities hard delete
6. **Encryption**: Some fields (task descriptions, chat messages) support optional encryption via `isEncrypted` flag

### Collection Organization

- **Root Collections**: `users`, `projects`, `tasks`, `subtasks`, `routines`, `invitations`, `mindMaps`, `mindMapNodes`
- **User Subcollections**: `sticky_notes`, `notifications`, `pendingInvitations` (under `users/{userId}/`)
- **Project Subcollections**: `members`, `messages` (under `projects/{projectId}/`)

---

## Collections

### 1. `users` Collection

**Path**: `users/{userId}`  
**Description**: User profiles and authentication data. Document ID matches Firebase Auth UID.

#### Document Structure

```json
{
  "id": "string",              // Firebase Auth UID (same as document ID)
  "email": "string",           // User email (lowercase, unique)
  "displayName": "string?",    // User display name (nullable)
  "photoUrl": "string?",       // Profile picture URL (nullable)
  "createdAt": "Timestamp",    // Account creation date
  "updatedAt": "Timestamp?"    // Last profile update (nullable)
}
```

#### Field Details

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | String | Yes | Firebase Auth UID |
| `email` | String | Yes | User email address |
| `displayName` | String? | No | Display name for UI |
| `photoUrl` | String? | No | Avatar image URL |
| `createdAt` | Timestamp | Yes | Account creation timestamp |
| `updatedAt` | Timestamp? | No | Last update timestamp |

#### Dart Model Reference
```dart
class AppUser {
  final String id;
  final String email;
  final String? displayName;
  final String? photoUrl;
  final DateTime? createdAt;
  final DateTime? updatedAt;
}
```

#### Notes
- `email` stored in lowercase for case-insensitive queries
- Flutter: Dates serialize to/from ISO 8601 strings in JSON, Timestamp in Firestore
- Web backend: Store dates as ISO 8601 strings or Firestore Timestamp

---

### 2. `projects` Collection

**Path**: `projects/{projectId}`  
**Description**: Collaborative workspaces with role-based access control.

#### Document Structure

```json
{
  "name": "string",                    // Project name
  "description": "string?",            // Optional project description
  "members": ["userId1", "userId2"],   // Array of member user IDs
  "ownerId": "string",                 // Creator/owner user ID
  "memberRoles": {                     // Map of userId -> role
    "userId1": "owner",
    "userId2": "editor"
  },
  "createdAt": "Timestamp",            // Creation timestamp
  "updatedAt": "Timestamp?"            // Last update timestamp
}
```

#### Field Details

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | String | Yes | Project name |
| `description` | String? | No | Project description |
| `members` | Array\<String\> | Yes | List of member user IDs |
| `ownerId` | String | Yes | Owner user ID |
| `memberRoles` | Map\<String,String\> | Yes | userId → role mapping |
| `createdAt` | Timestamp | Yes | Creation timestamp |
| `updatedAt` | Timestamp? | No | Last update timestamp |

#### Roles (String Enum)

```typescript
// Enum values stored as strings
type ProjectRole = "owner" | "admin" | "editor" | "viewer";
```

| Role | Permissions |
|------|-------------|
| `owner` | Full control, can delete project |
| `admin` | Manage members, edit project settings |
| `editor` | Create/edit tasks and content |
| `viewer` | Read-only access |

#### Dart Model Reference
```dart
enum ProjectRole { owner, admin, editor, viewer }

class Project {
  final String id;
  final String name;
  final String? description;
  final List<String> members;
  final String ownerId;
  final Map<String, String> memberRoles;
  final DateTime createdAt;
  final DateTime? updatedAt;
}
```

#### Queries
- **User's Projects**: `projects.where('members', 'array-contains', userId)`
- **Owned Projects**: `projects.where('ownerId', '==', userId)`

---

### 3. `tasks` Collection

**Path**: `tasks/{taskId}`  
**Description**: Work items within projects, supports recurrence, encryption, and assignments.

#### Document Structure

```json
{
  "projectId": "string",                     // Parent project ID
  "title": "string",                         // Task title
  "description": "string?",                  // Optional description
  "isDescriptionEncrypted": "boolean",       // Whether description is encrypted
  "dueDate": "Timestamp?",                   // Optional due date
  "status": "string",                        // pending | in_progress | completed
  "reminderEnabled": "boolean",              // Whether reminder is active
  "assignees": ["userId1", "userId2"],       // Assigned user IDs
  "assignedBy": "string?",                   // User who assigned task
  "assignedAt": "Timestamp?",                // Assignment timestamp
  "recurrencePattern": "string",             // none | daily | weekly | monthly
  "recurrenceInterval": "number",            // Repeat interval (1-999999)
  "recurrenceEndDate": "Timestamp?",         // When recurrence ends
  "parentRecurringTaskId": "string?",        // Reference to parent recurring task
  "createdAt": "Timestamp",                  // Creation timestamp
  "updatedAt": "Timestamp?"                  // Last update timestamp
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `projectId` | String | Yes | - | Parent project ID |
| `title` | String | Yes | - | Task title |
| `description` | String? | No | null | Task description |
| `isDescriptionEncrypted` | Boolean | Yes | false | Encryption flag |
| `dueDate` | Timestamp? | No | null | Due date |
| `status` | String | Yes | "pending" | Task status enum |
| `priority` | String | Yes | "medium" | Task priority level |
| `tags` | Array\<String\> | Yes | [] | Tags for filtering/categorizing |
| `reminderEnabled` | Boolean | Yes | false | Reminder active flag |
| `assignees` | Array\<String\> | Yes | [] | Assigned user IDs |
| `assignedBy` | String? | No | null | Assigner user ID |
| `assignedAt` | Timestamp? | No | null | Assignment time |
| `recurrencePattern` | String | Yes | "none" | Recurrence type |
| `recurrenceInterval` | Number | Yes | 1 | Repeat interval |
| `recurrenceEndDate` | Timestamp? | No | null | Recurrence end date |
| `parentRecurringTaskId` | String? | No | null | Parent recurring task |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `updatedAt` | Timestamp? | No | null | Last update timestamp |

#### Enums

**TaskStatus** (String):
```typescript
type TaskStatus = "pending" | "in_progress" | "completed";
```

**TaskPriority** (String):
```typescript
type TaskPriority = "low" | "medium" | "high" | "urgent";
```

**RecurrencePattern** (String):
```typescript
type RecurrencePattern = "none" | "daily" | "weekly" | "monthly";
```

#### Dart Model Reference
```dart
enum TaskStatus { pending, in_progress, completed }
enum TaskPriority { low, medium, high, urgent }
enum RecurrencePattern { none, daily, weekly, monthly }

class Task {
  final String id;
  final String projectId;
  final String title;
  final String? description;
  final bool isDescriptionEncrypted;
  final DateTime? dueDate;
  final TaskStatus status;
  final TaskPriority priority;
  final List<String> tags;
  final bool reminderEnabled;
  final List<String> assignees;
  final String? assignedBy;
  final DateTime? assignedAt;
  final RecurrencePattern recurrencePattern;
  final int recurrenceInterval;
  final DateTime? recurrenceEndDate;
  final String? parentRecurringTaskId;
  final DateTime createdAt;
  final DateTime? updatedAt;
}
```

#### Queries
- **Project Tasks**: `tasks.where('projectId', '==', projectId)`
- **Assigned Tasks**: `tasks.where('assignees', 'array-contains', userId)`
- **Overdue Tasks**: `tasks.where('dueDate', '<', now).where('status', '!=', 'completed')`
- **Recurring Tasks**: `tasks.where('recurrencePattern', '!=', 'none')`
- **High Priority Tasks**: `tasks.where('priority', 'in', ['high', 'urgent'])`
- **Tasks by Tag**: `tasks.where('tags', 'array-contains', 'bug')`

#### Indexes Required
```javascript
// Composite index for filtering by project and status
{ projectId: "asc", status: "asc" }

// Composite index for overdue tasks
{ status: "asc", dueDate: "asc" }

// Composite index for assigned tasks by status
{ assignees: "asc", status: "asc" }

// Composite index for priority filtering
{ projectId: "asc", priority: "asc" }

// Composite index for tags filtering
{ projectId: "asc", tags: "asc" }
```

---

### 4. `subtasks` Collection

**Path**: `subtasks/{subtaskId}`  
**Description**: Smaller work items within a parent task.

#### Document Structure

```json
{
  "taskId": "string",           // Parent task ID
  "title": "string",            // Subtask title
  "isCompleted": "boolean",     // Completion status
  "dueDate": "Timestamp?",      // Optional due date
  "createdAt": "Timestamp",     // Creation timestamp
  "updatedAt": "Timestamp?"     // Last update timestamp
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `taskId` | String | Yes | - | Parent task ID |
| `title` | String | Yes | - | Subtask description |
| `isCompleted` | Boolean | Yes | false | Completion flag |
| `dueDate` | Timestamp? | No | null | Optional due date |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `updatedAt` | Timestamp? | No | null | Last update timestamp |

#### Dart Model Reference
```dart
class Subtask {
  final String id;
  final String taskId;
  final String title;
  final bool isCompleted;
  final DateTime? dueDate;
  final DateTime createdAt;
  final DateTime? updatedAt;
}
```

#### Queries
- **Task Subtasks**: `subtasks.where('taskId', '==', taskId)`

---

### 5. `routines` Collection

**Path**: `routines/{routineId}`  
**Description**: Recurring habits and tasks scheduled by frequency (daily/weekly/custom).

#### Document Structure

```json
{
  "userId": "string",              // Owner user ID
  "title": "string",               // Routine title
  "description": "string?",        // Optional description
  "frequency": "string",           // daily | weekly | custom
  "daysOfWeek": [1, 3, 5],        // Array of day numbers (1=Mon, 7=Sun)
  "timeOfDay": "string?",          // Time in HH:mm format (24-hour)
  "isActive": "boolean",           // Whether routine is active
  "reminderEnabled": "boolean",    // Whether reminder is enabled
  "reminderMinutesBefore": "number", // Minutes before routine time
  "createdAt": "Timestamp",        // Creation timestamp
  "updatedAt": "Timestamp?"        // Last update timestamp
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `userId` | String | Yes | - | Owner user ID |
| `title` | String | Yes | - | Routine title |
| `description` | String? | No | null | Routine description |
| `frequency` | String | Yes | "daily" | Recurrence type |
| `daysOfWeek` | Array\<Number\> | Yes | [] | Days of week (1-7) |
| `timeOfDay` | String? | No | null | Time in HH:mm format |
| `isActive` | Boolean | Yes | true | Active flag |
| `reminderEnabled` | Boolean | Yes | false | Reminder flag |
| `reminderMinutesBefore` | Number | Yes | 15 | Reminder lead time |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `updatedAt` | Timestamp? | No | null | Last update timestamp |

#### Enums

**RoutineFrequency** (String):
```typescript
type RoutineFrequency = "daily" | "weekly" | "custom";
```

#### Dart Model Reference
```dart
enum RoutineFrequency { daily, weekly, custom }

class Routine {
  final String id;
  final String userId;
  final String title;
  final String? description;
  final RoutineFrequency frequency;
  final List<int> daysOfWeek;
  final String? timeOfDay;
  final bool isActive;
  final bool reminderEnabled;
  final int reminderMinutesBefore;
  final DateTime createdAt;
  final DateTime? updatedAt;
}
```

#### Queries
- **User Routines**: `routines.where('userId', '==', userId)`
- **Active Routines**: `routines.where('userId', '==', userId).where('isActive', '==', true)`

---

### 6. `invitations` Collection

**Path**: `invitations/{invitationId}`  
**Description**: Project membership invitations sent via email.

#### Document Structure

```json
{
  "projectId": "string",           // Target project ID
  "projectName": "string",         // Project name (denormalized)
  "invitedByUserId": "string",     // Inviter user ID
  "invitedByUserName": "string",   // Inviter display name
  "invitedEmail": "string",        // Invitee email (lowercase)
  "invitedUserId": "string?",      // Invitee user ID (if registered)
  "status": "string",              // pending | accepted | declined | cancelled
  "role": "string",                // owner | admin | editor | viewer
  "message": "string?",            // Optional personal message
  "createdAt": "Timestamp",        // Creation timestamp
  "respondedAt": "Timestamp?"      // Response timestamp
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `projectId` | String | Yes | - | Target project ID |
| `projectName` | String | Yes | - | Project name |
| `invitedByUserId` | String | Yes | - | Inviter user ID |
| `invitedByUserName` | String | Yes | - | Inviter display name |
| `invitedEmail` | String | Yes | - | Invitee email |
| `invitedUserId` | String? | No | null | Invitee user ID |
| `status` | String | Yes | "pending" | Invitation status |
| `role` | String | Yes | - | Offered role |
| `message` | String? | No | null | Personal message |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `respondedAt` | Timestamp? | No | null | Response timestamp |

#### Enums

**InvitationStatus** (String):
```typescript
type InvitationStatus = "pending" | "accepted" | "declined" | "cancelled";
```

**ProjectRole** (same as projects collection)

#### Dart Model Reference
```dart
enum InvitationStatus { pending, accepted, declined, cancelled }

class MemberInvitation {
  final String id;
  final String projectId;
  final String projectName;
  final String invitedByUserId;
  final String invitedByUserName;
  final String invitedEmail;
  final String? invitedUserId;
  final InvitationStatus status;
  final ProjectRole role;
  final String? message;
  final DateTime createdAt;
  final DateTime? respondedAt;
}
```

#### Queries
- **Pending Invitations by Email**: `invitations.where('invitedEmail', '==', email).where('status', '==', 'pending')`
- **Pending Invitations by User ID**: `invitations.where('invitedUserId', '==', userId).where('status', '==', 'pending')`
- **Project Invitations**: `invitations.where('projectId', '==', projectId)`

#### Indexes Required
```javascript
// Composite index for email + status
{ invitedEmail: "asc", status: "asc" }

// Composite index for userId + status
{ invitedUserId: "asc", status: "asc" }

// Composite index for projectId + status
{ projectId: "asc", status: "asc" }
```

---

### 7. `mindMaps` Collection

**Path**: `mindMaps/{mindMapId}`  
**Description**: Mind map containers with hierarchical node structures.

#### Document Structure

```json
{
  "title": "string",                    // Mind map title
  "description": "string?",             // Optional description
  "userId": "string",                   // Owner user ID
  "rootNodeId": "string",               // Root node ID reference
  "collaboratorIds": ["userId1"],       // Array of collaborator user IDs
  "createdAt": "Timestamp",             // Creation timestamp
  "updatedAt": "Timestamp?"             // Last update timestamp
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `title` | String | Yes | - | Mind map title |
| `description` | String? | No | null | Mind map description |
| `userId` | String | Yes | - | Owner user ID |
| `rootNodeId` | String | Yes | - | Root node document ID |
| `collaboratorIds` | Array\<String\> | Yes | [] | Collaborator user IDs |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `updatedAt` | Timestamp? | No | null | Last update timestamp |

#### Dart Model Reference
```dart
class MindMap {
  final String id;
  final String title;
  final String? description;
  final String userId;
  final String rootNodeId;
  final List<String> collaboratorIds;
  final DateTime createdAt;
  final DateTime? updatedAt;
}
```

#### Queries
- **User Mind Maps**: `mindMaps.where('userId', '==', userId)`
- **Collaborated Mind Maps**: `mindMaps.where('collaboratorIds', 'array-contains', userId)`

---

### 8. `mindMapNodes` Collection

**Path**: `mindMapNodes/{nodeId}`  
**Description**: Individual nodes within mind maps, forming a tree structure.

#### Document Structure

```json
{
  "mindMapId": "string",           // Parent mind map ID
  "text": "string",                // Node text content
  "parentId": "string?",           // Parent node ID (null for root)
  "childIds": ["nodeId1"],         // Array of child node IDs
  "x": "number",                   // X coordinate position
  "y": "number",                   // Y coordinate position
  "color": "string",               // blue | green | yellow | orange | red | purple | pink | gray
  "isCollapsed": "boolean",        // Whether node is collapsed
  "createdAt": "Timestamp",        // Creation timestamp
  "updatedAt": "Timestamp?"        // Last update timestamp
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `mindMapId` | String | Yes | - | Parent mind map ID |
| `text` | String | Yes | - | Node text content |
| `parentId` | String? | No | null | Parent node ID |
| `childIds` | Array\<String\> | Yes | [] | Child node IDs |
| `x` | Number | Yes | - | X coordinate |
| `y` | Number | Yes | - | Y coordinate |
| `color` | String | Yes | "blue" | Node color |
| `isCollapsed` | Boolean | Yes | false | Collapsed state |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `updatedAt` | Timestamp? | No | null | Last update timestamp |

#### Enums

**NodeColor** (String):
```typescript
type NodeColor = "blue" | "green" | "yellow" | "orange" | "red" | "purple" | "pink" | "gray";
```

#### Dart Model Reference
```dart
enum NodeColor { blue, green, yellow, orange, red, purple, pink, gray }

class MindMapNode {
  final String id;
  final String mindMapId;
  final String text;
  final String? parentId;
  final List<String> childIds;
  final double x;
  final double y;
  final NodeColor color;
  final bool isCollapsed;
  final DateTime createdAt;
  final DateTime? updatedAt;
}
```

#### Queries
- **Mind Map Nodes**: `mindMapNodes.where('mindMapId', '==', mindMapId)`
- **Child Nodes**: Query by `parentId` or use `childIds` array from parent

---

## Subcollections

### Subcollection: `projects/{projectId}/members`

**Path**: `projects/{projectId}/members/{userId}`  
**Description**: Detailed member information for each project. Document ID is the user ID.

#### Document Structure

```json
{
  "userId": "string",           // Member user ID (same as doc ID)
  "email": "string",            // Member email
  "displayName": "string",      // Member display name
  "photoUrl": "string?",        // Member photo URL
  "role": "string",             // owner | admin | editor | viewer
  "addedAt": "Timestamp",       // When member was added
  "addedBy": "string"           // User ID who added this member
}
```

#### Field Details

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `userId` | String | Yes | Member user ID |
| `email` | String | Yes | Member email |
| `displayName` | String | Yes | Display name |
| `photoUrl` | String? | No | Avatar URL |
| `role` | String | Yes | Member role |
| `addedAt` | Timestamp | Yes | Addition timestamp |
| `addedBy` | String | Yes | Adder user ID |

#### Dart Model Reference
```dart
class ProjectMember {
  final String userId;
  final String email;
  final String displayName;
  final String? photoUrl;
  final ProjectRole role;
  final DateTime addedAt;
  final String addedBy;
}
```

#### Notes
- Flutter: `addedAt` stored as ISO 8601 string, converted to Timestamp
- Web backend: Use Firestore Timestamp directly

---

### Subcollection: `projects/{projectId}/messages`

**Path**: `projects/{projectId}/messages/{messageId}`  
**Description**: Real-time chat messages within projects. Supports encryption and soft deletes.

#### Document Structure

```json
{
  "projectId": "string",        // Parent project ID (denormalized)
  "senderId": "string",         // Sender user ID
  "senderName": "string",       // Sender display name
  "text": "string",             // Message text content
  "isEncrypted": "boolean",     // Whether text is encrypted
  "createdAt": "Timestamp",     // Creation timestamp
  "editedAt": "Timestamp?",     // Last edit timestamp
  "isDeleted": "boolean"        // Soft delete flag
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `projectId` | String | Yes | - | Parent project ID |
| `senderId` | String | Yes | - | Sender user ID |
| `senderName` | String | Yes | - | Sender display name |
| `text` | String | Yes | - | Message content |
| `isEncrypted` | Boolean | Yes | false | Encryption flag |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `editedAt` | Timestamp? | No | null | Edit timestamp |
| `isDeleted` | Boolean | Yes | false | Soft delete flag |

#### Dart Model Reference
```dart
class ChatMessage {
  final String id;
  final String projectId;
  final String senderId;
  final String senderName;
  final String text;
  final bool isEncrypted;
  final DateTime createdAt;
  final DateTime? editedAt;
  final bool isDeleted;
}
```

#### Queries
- **Project Messages**: Real-time stream on subcollection path
- **Undeleted Messages**: `messages.where('isDeleted', '==', false).orderBy('createdAt')`

---

### Subcollection: `users/{userId}/sticky_notes`

**Path**: `users/{userId}/sticky_notes/{noteId}`  
**Description**: Personal sticky notes with canvas positioning and rich text support.

#### Document Structure

```json
{
  "title": "string?",           // Optional note title
  "content": "string",          // Note content (Quill Delta JSON)
  "color": "string",            // yellow | pink | blue | green | purple | orange
  "position": {                 // Canvas position
    "x": "number",
    "y": "number"
  },
  "userId": "string",           // Owner user ID (denormalized)
  "zIndex": "number",           // Z-index for layering
  "width": "number",            // Note width in pixels
  "height": "number",           // Note height in pixels
  "createdAt": "Timestamp",     // Creation timestamp
  "updatedAt": "Timestamp?"     // Last update timestamp
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `title` | String? | No | null | Note title |
| `content` | String | Yes | - | Rich text content |
| `color` | String | Yes | "yellow" | Note color |
| `position` | Object | Yes | {x:0, y:0} | Canvas position |
| `userId` | String | Yes | - | Owner user ID |
| `zIndex` | Number | Yes | 0 | Z-index layering |
| `width` | Number | Yes | 200.0 | Note width |
| `height` | Number | Yes | 200.0 | Note height |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `updatedAt` | Timestamp? | No | null | Last update timestamp |

#### Enums

**NoteColor** (String):
```typescript
type NoteColor = "yellow" | "pink" | "blue" | "green" | "purple" | "orange";
```

#### Dart Model Reference
```dart
enum NoteColor { yellow, pink, blue, green, purple, orange }

class NotePosition {
  final double x;
  final double y;
}

class StickyNote {
  final String id;
  final String? title;
  final String content;
  final NoteColor color;
  final NotePosition position;
  final String userId;
  final int zIndex;
  final double width;
  final double height;
  final DateTime createdAt;
  final DateTime? updatedAt;
}
```

---

### Subcollection: `users/{userId}/notifications`

**Path**: `users/{userId}/notifications/{notificationId}`  
**Description**: In-app notifications for users (invitations, task assignments, project updates).

#### Document Structure

```json
{
  "userId": "string",                   // Recipient user ID (denormalized)
  "type": "string",                     // See NotificationType enum below
  "title": "string",                    // Notification title
  "body": "string",                     // Notification message
  "imageUrl": "string?",                // Optional image (avatar, icon)
  "data": {                             // Contextual data (project ID, task ID, etc.)
    "projectId": "string",
    "taskId": "string"
  },
  "createdAt": "Timestamp",             // Creation timestamp
  "isRead": "boolean",                  // Read status
  "actionUrl": "string?"                // Deep link URL for navigation
}
```

#### Field Details

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `userId` | String | Yes | - | Recipient user ID |
| `type` | String | Yes | - | Notification type |
| `title` | String | Yes | - | Notification title |
| `body` | String | Yes | - | Notification message |
| `imageUrl` | String? | No | null | Image URL |
| `data` | Object | Yes | {} | Contextual data |
| `createdAt` | Timestamp | Yes | - | Creation timestamp |
| `isRead` | Boolean | Yes | false | Read status |
| `actionUrl` | String? | No | null | Deep link URL |

#### Enums

**NotificationType** (String):
```typescript
type NotificationType = 
  | "invitationReceived"
  | "invitationAccepted"
  | "invitationDeclined"
  | "taskAssigned"
  | "taskReassigned"
  | "taskUnassigned"
  | "taskCompleted"
  | "taskCommentAdded"
  | "taskDueSoon"
  | "taskOverdue"
  | "memberAdded"
  | "memberRemoved"
  | "memberRoleChanged"
  | "projectShared"
  | "projectArchived"
  | "taskReminder"
  | "routineReminder";
```

#### Dart Model Reference
```dart
enum NotificationType {
  invitationReceived, invitationAccepted, invitationDeclined,
  taskAssigned, taskReassigned, taskUnassigned, taskCompleted,
  taskCommentAdded, taskDueSoon, taskOverdue,
  memberAdded, memberRemoved, memberRoleChanged,
  projectShared, projectArchived,
  taskReminder, routineReminder
}

class AppNotification {
  final String id;
  final String userId;
  final NotificationType type;
  final String title;
  final String body;
  final String? imageUrl;
  final Map<String, dynamic> data;
  final DateTime createdAt;
  final bool isRead;
  final String? actionUrl;
}
```

#### Queries
- **User Notifications**: Real-time stream on subcollection path
- **Unread Notifications**: `notifications.where('isRead', '==', false).orderBy('createdAt', descending: true)`

---

### Subcollection: `users/{userId}/pendingInvitations`

**Path**: `users/{userId}/pendingInvitations/{invitationId}`  
**Description**: Lightweight references to pending invitations for quick badge counts. Document ID matches invitation ID in root `invitations` collection.

#### Document Structure

```json
{
  "invitationId": "string",     // Reference to invitations/{invitationId}
  "projectId": "string",        // Project ID
  "projectName": "string",      // Project name (denormalized)
  "invitedBy": "string",        // Inviter display name
  "createdAt": "Timestamp"      // Invitation timestamp
}
```

#### Field Details

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `invitationId` | String | Yes | Invitation document ID |
| `projectId` | String | Yes | Project ID |
| `projectName` | String | Yes | Project name |
| `invitedBy` | String | Yes | Inviter name |
| `createdAt` | Timestamp | Yes | Creation timestamp |

#### Notes
- This is a denormalized cache for quick badge count queries
- Source of truth is `invitations/{invitationId}` collection
- Deleted when invitation is accepted/declined/cancelled

---

## Data Type Mapping

### Firestore → Dart

| Firestore Type | Dart Type | Notes |
|----------------|-----------|-------|
| `string` | `String` | UTF-8 encoded |
| `number` | `int`, `double` | Check context |
| `boolean` | `bool` | - |
| `Timestamp` | `DateTime` | Converted via `.toDate()` |
| `array` | `List<T>` | Typed lists |
| `map` | `Map<String, dynamic>` | Nested objects |
| `reference` | `DocumentReference` | Rarely used directly |

### Firestore → JavaScript (Web Backend)

| Firestore Type | JavaScript Type | Notes |
|----------------|-----------------|-------|
| `string` | `string` | - |
| `number` | `number` | No int/double distinction |
| `boolean` | `boolean` | - |
| `Timestamp` | `Timestamp` | Use `.toDate()` for Date object |
| `array` | `Array` | - |
| `map` | `Object` | Nested objects |

---

## Timestamp Handling

### Best Practices

1. **Firestore Storage**: Always store dates as `Timestamp` type
2. **Flutter Serialization**:
   - Firestore: `Timestamp.fromDate(dateTime)` / `timestamp.toDate()`
   - JSON: `dateTime.toIso8601String()` / `DateTime.parse(string)`
3. **Web Backend**: Use `admin.firestore.FieldValue.serverTimestamp()` for creation
4. **Null Handling**: `updatedAt`, `respondedAt`, etc. can be null for new documents

### Example Conversions

**Flutter (Dart)**:
```dart
// Firestore → Dart
DateTime createdAt = (data['createdAt'] as Timestamp).toDate();

// Dart → Firestore
Map<String, dynamic> toFirestore() {
  return {
    'createdAt': Timestamp.fromDate(createdAt),
  };
}

// Dart → JSON (for Hive/local)
String toJson() {
  return createdAt.toIso8601String();
}
```

**Web Backend (Node.js)**:
```javascript
// Create with server timestamp
await firestore.collection('tasks').add({
  ...taskData,
  createdAt: admin.firestore.FieldValue.serverTimestamp()
});

// Read timestamp
const task = await docRef.get();
const createdAt = task.data().createdAt.toDate(); // JavaScript Date
```

---

## Enum Serialization

### Storage Format

All enums stored as **lowercase string matching enum value name**.

**Example**:
```dart
enum TaskStatus { pending, in_progress, completed }

// Firestore: "pending", "in_progress", "completed"
status.name // Returns "pending"
```

### Conversion Examples

**Flutter (Dart)**:
```dart
// Enum → String
String toFirestore() => status.name;

// String → Enum
TaskStatus fromFirestore(String value) {
  return TaskStatus.values.firstWhere(
    (e) => e.name == value,
    orElse: () => TaskStatus.pending,
  );
}
```

**Web Backend (Node.js)**:
```javascript
// No native enums, use string constants
const TaskStatus = {
  PENDING: 'pending',
  IN_PROGRESS: 'in_progress',
  COMPLETED: 'completed'
};

// Store directly
await taskRef.update({ status: TaskStatus.COMPLETED });
```

### Enum Reference Table

| Enum | Values | Collection |
|------|--------|------------|
| `TaskStatus` | `pending`, `in_progress`, `completed` | `tasks` |
| `TaskPriority` | `low`, `medium`, `high`, `urgent` | `tasks` |
| `RecurrencePattern` | `none`, `daily`, `weekly`, `monthly` | `tasks` |
| `RoutineFrequency` | `daily`, `weekly`, `custom` | `routines` |
| `ProjectRole` | `owner`, `admin`, `editor`, `viewer` | `projects`, `invitations`, `members` |
| `InvitationStatus` | `pending`, `accepted`, `declined`, `cancelled` | `invitations` |
| `NoteColor` | `yellow`, `pink`, `blue`, `green`, `purple`, `orange` | `sticky_notes` |
| `NodeColor` | `blue`, `green`, `yellow`, `orange`, `red`, `purple`, `pink`, `gray` | `mindMapNodes` |
| `NotificationType` | (17 values, see above) | `notifications` |

---

## Indexes Required

Firestore requires composite indexes for multi-field queries.

### Critical Indexes

```javascript
// 1. Tasks: Project + Status filter
{
  collection: "tasks",
  fields: [
    { fieldPath: "projectId", order: "ASCENDING" },
    { fieldPath: "status", order: "ASCENDING" }
  ]
}

// 2. Tasks: Assignees + Status filter
{
  collection: "tasks",
  fields: [
    { fieldPath: "assignees", arrayConfig: "CONTAINS" },
    { fieldPath: "status", order: "ASCENDING" }
  ]
}

// 3. Tasks: Overdue query (status != completed, dueDate < now)
{
  collection: "tasks",
  fields: [
    { fieldPath: "status", order: "ASCENDING" },
    { fieldPath: "dueDate", order: "ASCENDING" }
  ]
}

// 4. Invitations: Email + Status
{
  collection: "invitations",
  fields: [
    { fieldPath: "invitedEmail", order: "ASCENDING" },
    { fieldPath: "status", order: "ASCENDING" }
  ]
}

// 5. Invitations: User ID + Status
{
  collection: "invitations",
  fields: [
    { fieldPath: "invitedUserId", order: "ASCENDING" },
    { fieldPath: "status", order: "ASCENDING" }
  ]
}

// 6. Invitations: Project + Status
{
  collection: "invitations",
  fields: [
    { fieldPath: "projectId", order: "ASCENDING" },
    { fieldPath: "status", order: "ASCENDING" }
  ]
}
```

### Index Creation

**Firebase Console**:
1. Go to Firestore → Indexes
2. Click "Create Index"
3. Add collection and fields
4. Deploy

**Firebase CLI** (`firestore.indexes.json`):
```json
{
  "indexes": [
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    }
  ]
}
```

Deploy:
```bash
firebase deploy --only firestore:indexes
```

---

## Security Rules Summary

> **Full rules**: See `firestore.rules` file in project root.

### Key Principles

1. **Authentication Required**: All reads/writes require `request.auth != null`
2. **User Data Isolation**: Users can only access their own user subcollections
3. **Project Members Only**: Project resources restricted to members array
4. **Role-Based Writes**: Admins/owners for member management, editors for content
5. **Invitation Permissions**: Invitees can read/update, inviters can cancel

### Example Rules

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users can read/write their own profile
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // User's sticky notes
      match /sticky_notes/{noteId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // User's notifications
      match /notifications/{notificationId} {
        allow read, update, delete: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null; // System can create
      }
    }
    
    // Projects: Members can read, specific roles can write
    match /projects/{projectId} {
      allow read: if request.auth != null && isMember(projectId);
      allow update: if request.auth != null && isProjectAdmin(projectId);
      allow delete: if request.auth != null && isProjectOwner(projectId);
      
      // Project members
      match /members/{userId} {
        allow read: if request.auth != null && isMember(projectId);
        allow create, delete, update: if request.auth != null && isProjectAdmin(projectId);
      }
      
      // Project messages
      match /messages/{messageId} {
        allow read: if request.auth != null && isMember(projectId);
        allow create: if request.auth != null && isMember(projectId);
        allow update, delete: if request.auth != null && 
          resource.data.senderId == request.auth.uid;
      }
    }
    
    // Tasks: Project members only
    match /tasks/{taskId} {
      allow read: if request.auth != null && isMember(resource.data.projectId);
      allow create, update: if request.auth != null && 
        isMember(request.resource.data.projectId);
      allow delete: if request.auth != null && 
        isProjectAdmin(resource.data.projectId);
    }
    
    // Invitations
    match /invitations/{invitationId} {
      allow read: if request.auth != null && (
        resource.data.invitedEmail == request.auth.token.email ||
        resource.data.invitedUserId == request.auth.uid ||
        resource.data.invitedByUserId == request.auth.uid
      );
      allow create: if request.auth != null && 
        isProjectAdmin(request.resource.data.projectId);
      allow update: if request.auth != null && (
        resource.data.invitedUserId == request.auth.uid ||
        resource.data.invitedEmail == request.auth.token.email
      );
      allow delete: if request.auth != null && 
        resource.data.invitedByUserId == request.auth.uid;
    }
    
    // Helper functions
    function isMember(projectId) {
      return exists(/databases/$(database)/documents/projects/$(projectId)/members/$(request.auth.uid));
    }
    
    function isProjectAdmin(projectId) {
      let project = get(/databases/$(database)/documents/projects/$(projectId));
      let role = project.data.memberRoles[request.auth.uid];
      return role in ['owner', 'admin'];
    }
    
    function isProjectOwner(projectId) {
      let project = get(/databases/$(database)/documents/projects/$(projectId));
      return project.data.ownerId == request.auth.uid;
    }
  }
}
```

---

## Consistency Guidelines

### For Developers

1. **Always Reference This Document**: Before implementing new features, check field names and types here.

2. **Field Naming Convention**:
   - Use `camelCase` for field names
   - Boolean fields: prefix with `is` (e.g., `isCompleted`, `isEncrypted`)
   - Timestamps: suffix with `At` (e.g., `createdAt`, `updatedAt`)

3. **Timestamp Creation**:
   - **Flutter**: Use `FieldValue.serverTimestamp()` for Firestore writes
   - **Web Backend**: Use `admin.firestore.FieldValue.serverTimestamp()`
   - **Never** use client-side `DateTime.now()` for creation timestamps (clock skew issues)

4. **Enum Storage**:
   - Always store enum values as **lowercase strings** matching enum name
   - Example: `TaskStatus.in_progress` → `"in_progress"`

5. **Null Handling**:
   - Nullable fields explicitly marked with `?` in Dart, `nullable` in docs
   - Always provide `orElse` defaults when parsing nullable enums

6. **Array Fields**:
   - Use `FieldValue.arrayUnion()` and `FieldValue.arrayRemove()` for atomic updates
   - Never overwrite entire arrays without reading first

7. **ID Storage**:
   - Store parent IDs in child documents for query optimization (e.g., `projectId` in tasks)
   - Document IDs match collection IDs (e.g., `users/{userId}` where doc `id` field = `userId`)

8. **Testing Changes**:
   - Test both Flutter app and web backend after schema changes
   - Verify offline-first sync in Flutter (Hive cache consistency)
   - Check security rules still allow intended operations

### For Code Reviews

- [ ] Field names match exactly (`camelCase`, correct spelling)
- [ ] Timestamps use `Timestamp` type, not strings or milliseconds
- [ ] Enums serialized as lowercase strings
- [ ] Nullable fields handled with null-checks
- [ ] Indexes created for multi-field queries
- [ ] Security rules updated if collection structure changes
- [ ] Both Flutter and web backend code updated

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | January 2025 | Initial comprehensive documentation covering all collections and subcollections |

---

## Related Documentation

- **Firestore Rules**: `firestore.rules` in project root
- **Firestore Indexes**: `firestore.indexes.json`
- **Flutter Models**: `lib/src/features/*/domain/models/`
- **Web Backend Controllers**: `Tasker Backend/src/controllers/`
- **Phase 1 Completion Report**: `docs/phase-1-completion-report.md`
- **Phase 2 Completion Report**: `docs/phase-2-completion-report.md`
- **Collaboration Features Plan**: `docs/collaboration-features-plan.md`

---

**End of Document**
